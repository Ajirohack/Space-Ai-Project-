[{"id":"n8n_pipe_ng","user_id":"ba2286c0-5b0b-4be8-99bb-2cd12b9fc1b3","name":"N8N Pipe NG","type":"pipe","content":"\"\"\"N8N Pipe Function for OpenWebUI.\n\nThis module provides a connector between Open-WebUI and n8n workflows.\n\ntitle: N8N Pipe Function\nauthor: Sylvain BOILY (fork from https://openwebui.com/f/coleam/n8n_pipe)\nauthor_url: https://github.com/sboily/open-webui-n8n-pipe\nfunding_url: https://github.com/sboily/open-webui-n8n-pipe\nversion: 0.2\n\"\"\"\n\nimport logging\nimport time\nfrom typing import Any, Awaitable, Callable, Dict, Optional, Union\nfrom urllib.parse import urljoin\n\n# Add type stubs for missing libraries\ntry:\n    import httpx\n    from pydantic import BaseModel, Field, validator\nexcept ImportError:\n    # For type checking only\n    pass\n\n\n# Configure logger\nlogger = logging.getLogger(__name__)\n\n\nclass Pipe:\n    \"\"\"N8N Pipe connector for Open-WebUI.\n\n    This class implements an asynchronous connector between Open-WebUI\n    and n8n workflows for redirecting chat messages.\n    \"\"\"\n\n    class Valves(BaseModel):\n        \"\"\"Configuration parameters for the N8N Pipe connector.\"\"\"\n\n        n8n_host: str = Field(\n            default=\"http://localhost:5678\",\n            description=\"Base URL for n8n server (without trailing slash)\",\n        )\n        n8n_webhook_id: str = Field(\n            default=\"your-webhook-id\",\n            description=\"Webhook ID from n8n\",\n        )\n        n8n_test_mode: bool = Field(\n            default=False,\n            description=\"Whether to use test mode URLs for n8n webhooks\",  # NOQA\n        )\n        n8n_bearer_token: str = Field(\n            default=\"your-token-here\",\n            description=\"Bearer token for n8n authentication\",  # NOQA\n        )\n        input_field: str = Field(\n            default=\"chatInput\",\n            description=\"Field name for the input in the JSON payload\",\n        )\n        response_field: str = Field(\n            default=\"output\",\n            description=\"Field name for the output in the response JSON\",\n        )\n        emit_interval: float = Field(\n            default=2.0,\n            description=\"Interval in seconds between status emissions\",  # NOQA\n        )\n        enable_status_indicator: bool = Field(\n            default=True,\n            description=\"Enable or disable status indicator emissions\",  # NOQA\n        )\n        timeout: float = Field(\n            default=30.0, description=\"Timeout for HTTP requests in seconds\"\n        )  # NOQA\n        max_retries: int = Field(\n            default=2,\n            description=\"Maximum number of retries for failed requests\",  # NOQA\n        )\n        history_limit: int = Field(\n            default=10,\n            description=\"Maximum number of messages to include in history\",  # NOQA\n        )\n\n        @validator(\"n8n_host\")\n        def validate_host_url(cls, v: str) -> str:\n            \"\"\"Validate that the n8n host URL includes a protocol.\n\n            Args:\n                v: The URL to validate\n\n            Returns:\n                The validated URL if it passes validation\n\n            Raises:\n                ValueError: If the URL does not start with http:// or https://\n            \"\"\"\n            if not v.startswith((\"http://\", \"https://\")):\n                raise ValueError(\"n8n_host must start with http:// or https://\")  # NOQA\n            return v\n\n    def __init__(self) -> None:\n        \"\"\"Initialize the N8N Pipe connector.\"\"\"\n        self.type = \"pipe\"\n        self.id = \"n8n_pipe\"\n        self.name = \"N8N Pipe\"\n        self.valves = self.Valves()\n        self.last_emit_time: float = 0.0\n        self._http_client = httpx.AsyncClient(timeout=self.valves.timeout)\n        logger.info(f\"Initialized {self.name}\")\n\n    async def __aenter__(self) -> \"Pipe\":\n        \"\"\"Async context manager entry method.\n\n        Returns:\n            Self, for use in async with statements\n        \"\"\"\n        logger.debug(\"Entering async context\")\n        return self\n\n    async def __aexit__(self, exc_type: Any, exc_val: Any, exc_tb: Any) -> None:  # NOQA\n        \"\"\"Async context manager exit method, closes the HTTP client.\n\n        Args:\n            exc_type: Exception type, if an exception was raised\n            exc_val: Exception value, if an exception was raised\n            exc_tb: Exception traceback, if an exception was raised\n        \"\"\"\n        logger.debug(\"Exiting async context\")\n        await self._http_client.aclose()\n\n    async def emit_status(\n        self,\n        __event_emitter__: Optional[Callable[[dict], Awaitable[None]]],\n        level: str,\n        message: str,\n        done: bool,\n    ) -> None:\n        \"\"\"Emit status update if conditions are met.\n\n        Args:\n            __event_emitter__: Callable to emit status events\n            level: Status level (info, warning, error)\n            message: Status description\n            done: Whether this is a completion status\n        \"\"\"\n        if not __event_emitter__:\n            return\n\n        current_time = time.time()\n        if self.valves.enable_status_indicator and (\n            current_time - self.last_emit_time >= self.valves.emit_interval\n            or done  # NOQA\n        ):\n            logger.debug(f\"Emitting status: {level} - {message}\")\n            await __event_emitter__(\n                {\n                    \"type\": \"status\",\n                    \"data\": {\n                        \"status\": \"complete\" if done else \"in_progress\",\n                        \"level\": level,\n                        \"description\": message,\n                        \"done\": done,\n                    },\n                }\n            )\n            self.last_emit_time = current_time\n\n    def get_webhook_url(self) -> str:\n        \"\"\"Build the n8n webhook URL based on configuration settings.\n\n        Returns:\n            Complete webhook URL with appropriate path for test\n            or production mode\n        \"\"\"\n        base_url = self.valves.n8n_host.rstrip(\"/\")\n        webhook_id = self.valves.n8n_webhook_id\n        path = (\n            f\"/webhook-test/{webhook_id}\"\n            if self.valves.n8n_test_mode\n            else f\"/webhook/{webhook_id}\"  # NOQA\n        )\n        return urljoin(f\"{base_url}/\", path.lstrip(\"/\"))\n\n    def _extract_question(self, content: str) -> str:\n        \"\"\"Extract the actual question from the content string.\n\n        Args:\n            content: The message content to process\n\n        Returns:\n            The cleaned question string\n        \"\"\"\n        return (\n            content.split(\"Prompt: \")[-1] if \"Prompt: \" in content else content\n        )  # NOQA\n\n    def _create_session_id(\n        self, user: Optional[Dict[str, Any]], first_message: Optional[str]\n    ) -> str:\n        \"\"\"Create a session identifier for the n8n workflow.\n\n        Args:\n            user: User information if available\n            first_message: The first message in the conversation\n\n        Returns:\n            A session identifier string\n        \"\"\"\n        user_id = user[\"id\"] if user and \"id\" in user else \"anonymous\"\n        message_prefix = \"\"\n\n        if first_message:\n            # Clean and truncate the first message\n            clean_message = self._extract_question(first_message)[:100]\n            message_prefix = f\" - {clean_message}\"\n\n        return f\"{user_id}{message_prefix}\"\n\n    async def _handle_http_error(\n        self,\n        error: Exception,\n        __event_emitter__: Optional[Callable[[dict], Awaitable[None]]],\n    ) -> Dict[str, str]:\n        \"\"\"Handle HTTP and other errors uniformly.\n\n        Args:\n            error: The exception that was raised\n            __event_emitter__: Callable to emit status events\n\n        Returns:\n            Error response dictionary\n        \"\"\"\n        error_msg = str(error)\n        logger.error(f\"Error in n8n pipe: {error_msg}\")\n\n        await self.emit_status(\n            __event_emitter__,\n            \"error\",\n            f\"Error during sequence execution: {error_msg}\",\n            True,\n        )\n\n        return {\"error\": error_msg}\n\n    async def pipe(\n        self,\n        body: Dict[str, Any],\n        __user__: Optional[Dict[str, Any]] = None,\n        __event_emitter__: Optional[Callable[[dict], Awaitable[None]]] = None,\n        __event_call__: Optional[Callable[[dict], Awaitable[dict]]] = None,\n    ) -> Union[Dict[str, str], str, Any]:\n        \"\"\"Process the incoming request and return the response from N8N.\n\n        Args:\n            body: Request body containing messages\n            __user__: User information (optional)\n            __event_emitter__: Callable to emit status events\n            __event_call__: Callable for event calls\n\n        Returns:\n            N8N response or error dictionary\n        \"\"\"\n        await self.emit_status(\n            __event_emitter__, \"info\", \"Calling N8N Workflow...\", False\n        )  # NOQA\n\n        messages = body.get(\"messages\", [])\n\n        # Check if messages list is empty\n        if not messages:\n            await self.emit_status(\n                __event_emitter__,\n                \"error\",\n                \"No messages found in the request body\",\n                True,\n            )\n\n            # Add response message\n            error_message = \"No messages found in the request body\"\n            body[\"messages\"] = body.get(\"messages\", []) + [\n                {\"role\": \"assistant\", \"content\": error_message}\n            ]\n            return {\"error\": error_message}\n\n        # Extract the latest question\n        last_message = messages[-1]\n        if last_message.get(\"role\") != \"user\":\n            await self.emit_status(\n                __event_emitter__,\n                \"error\",\n                \"Last message is not from user\",\n                True,\n            )\n            error_message = \"The last message must be from a user\"\n            body[\"messages\"].append(\n                {\"role\": \"assistant\", \"content\": error_message}\n            )  # NOQA\n            return {\"error\": error_message}\n\n        question = last_message.get(\"content\", \"\")\n        question = self._extract_question(question)\n\n        # If no question content found\n        if not question.strip():\n            await self.emit_status(\n                __event_emitter__,\n                \"warning\",\n                \"Empty question received\",\n                True,\n            )\n            error_message = \"Please provide a non-empty question\"\n            body[\"messages\"].append(\n                {\"role\": \"assistant\", \"content\": error_message}\n            )  # NOQA\n            return {\"error\": error_message}\n\n        try:\n            # Extract first message content for session ID\n            first_message_content = \"\"\n            if messages and messages[0].get(\"content\"):\n                first_message_content = messages[0][\"content\"]\n\n            # Create session ID\n            session_id = self._create_session_id(\n                __user__, first_message_content\n            )  # NOQA\n\n            # Prepare the payload\n            payload = {\"sessionId\": session_id}\n            payload[self.valves.input_field] = question\n\n            # Get headers\n            headers = {\n                \"Authorization\": f\"Bearer {self.valves.n8n_bearer_token}\",\n                \"Content-Type\": \"application/json\",\n            }\n\n            # Get the appropriate webhook URL\n            webhook_url = self.get_webhook_url()\n            logger.info(f\"Calling n8n webhook at: {webhook_url}\")\n\n            # Try request with retries\n            n8n_response: Optional[str] = None\n            retry_count = 0\n            last_error: Optional[Exception] = None\n\n            while retry_count <= self.valves.max_retries:\n                try:\n                    await self.emit_status(\n                        __event_emitter__,\n                        \"info\",\n                        f\"Attempt {retry_count + 1}/{self.valves.max_retries + 1}\",  # NOQA\n                        False,\n                    )\n\n                    # Use httpx for async HTTP request\n                    response = await self._http_client.post(\n                        webhook_url, json=payload, headers=headers\n                    )\n\n                    # Check status code\n                    if response.status_code == 200:\n                        response_json = response.json()\n                        if self.valves.response_field in response_json:\n                            n8n_response = response_json[\n                                self.valves.response_field\n                            ]  # NOQA\n                            break\n                        else:\n                            raise KeyError(\n                                f\"Response field '{self.valves.response_field}'\"  # NOQA\n                                \" not found in N8N response\"\n                            )\n                    else:\n                        raise httpx.HTTPStatusError(\n                            f\"Error: {response.status_code} - {response.text}\",\n                            request=response.request,\n                            response=response,\n                        )\n\n                except (httpx.HTTPError, KeyError) as e:\n                    last_error = e\n                    retry_count += 1\n                    if retry_count <= self.valves.max_retries:\n                        await self.emit_status(\n                            __event_emitter__,\n                            \"warning\",\n                            f\"Retry {retry_count}/{self.valves.max_retries}\",\n                            False,\n                        )\n                        time.sleep(1)  # Simple backoff\n\n            # If we've exhausted retries\n            if n8n_response is None and last_error is not None:\n                return await self._handle_http_error(\n                    last_error, __event_emitter__\n                )  # NOQA\n\n            # Set assistant message with workflow reply\n            body[\"messages\"].append(\n                {\"role\": \"assistant\", \"content\": n8n_response}\n            )  # NOQA\n\n            # Limit history if configured\n            if (\n                self.valves.history_limit > 0\n                and len(body[\"messages\"]) > self.valves.history_limit  # NOQA\n            ):  # NOQA\n                body[\"messages\"] = body[\"messages\"][\n                    -self.valves.history_limit :\n                ]  # NOQA\n\n            await self.emit_status(__event_emitter__, \"info\", \"Complete\", True)\n            return n8n_response\n\n        except Exception as e:\n            return await self._handle_http_error(e, __event_emitter__)\n","meta":{"description":"Asynchronous connector linking Open-WebUI chat interfaces with n8n workflows.","manifest":{}},"is_active":true,"is_global":false,"updated_at":1741999729,"created_at":1741952357}]